<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>SOFTWARE: ACR: Advanced Code Generation for Digital Signal Processing Algorithms</AwardTitle>
    <AwardEffectiveDate>04/01/2003</AwardEffectiveDate>
    <AwardExpirationDate>03/31/2007</AwardExpirationDate>
    <AwardAmount>463800</AwardAmount>
    <AwardInstrument>
      <Value>Continuing grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05010000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division of Computing and Communication Foundations</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Almadena Y. Chtchelkanova</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>The goal of this research is to automatically generate implementations of digital signal processing (DSP) transform algorithms that are adapted to a given off-the-shelf computing platform, i.e., the generated code takes full advantage of architectural features and available instructions sets, including the memory hierarchy, multiple processors, vector instructions, fused multiply-add instructions, and prefetching instructions. We refer to this type of code as "advanced code'' for two reasons: (1) the code uses instructions that are&lt;br/&gt;significantly beyond standard C or Fortran programming; and (2) manually writing such code requires a very high level of programming expertise including assembly level programming and a deep understanding of the platform's architecture. Our goal is ambitious: automatically generate code that competes with or outperforms expertly hand-tuned code for DSP algorithms.&lt;br/&gt;&lt;br/&gt;Our approach is based on the following: (1) We represent each fast DSP&lt;br/&gt;transform algorithm as a formula in a concise mathematical language. (2) We derive for each transform a very large number of structurally different fast algorithms or formulas. (3) These different formulas (i.e., algorithms) are efficiently enumerated and manipulated. (4) We automatically translate each formula into advanced code. (5) We optimize the implementation by searching over the space of alternative formulas and code implementations.&lt;br/&gt;&lt;br/&gt;Step (4) is the key claim---the automation step---of our approach. In other words, the applicability of advanced instructions, including vector instructions, parallel threads, fused multiply-add instructions, and prefetching instructions, can be related to mathematical constructs in our formula notation. Step (5) provides the&lt;br/&gt;tuning and adaptability of the code to the platform.&lt;br/&gt;&lt;br/&gt;We will research the mapping from formulas to advanced code and formalize it in a way suitable for automatic code generation and optimization. We will develop a compiler that translates a formula description of a fast DSP algorithm, possibly augmented with parameters that control coding degrees of freedom, into advanced code. Finally, we will build an "Advanced Code Generator'' that interfaces our compiler with a formula generator and a search module to&lt;br/&gt;automatically explore the space of structurally distinct fast algorithms and the space of advanced coding degrees of freedom. For a given DSP transform, our Advanced Code Generator automatically finds the formula, i.e., the algorithm, whose structure allows the best implementation given the available advanced instructions and given the computing platform.&lt;br/&gt;&lt;br/&gt;In contradistinction to other approaches to advanced code generation, including approaches using optimizing C or Fortran compilers or manual coding, our Advanced Code Generator automates and integrates the optimization at the mathematical level of algorithms and the optimization at the implementation level of machine-specific instructions. This way the Advanced Code Generator has access to all structural information necessary to produce high quality code and&lt;br/&gt;mimics a highly skilled programmer who understands and exploits the structure of algorithms and the given architecture to write platform-tuned advanced code. We believe that our research makes, for the performance-critical class of DSP algorithms, a pioneering step towards a solution for one of the present fundamental problems in software development for high performance scientific computing: How to develop, with reasonable effort, optimal and portable performance on increasingly complex and diverse off-the-shelf computing platforms.</AbstractNarration>
    <MinAmdLetterDate>02/13/2003</MinAmdLetterDate>
    <MaxAmdLetterDate>06/02/2005</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>0234293</AwardID>
    <Investigator>
      <FirstName>Jose</FirstName>
      <LastName>Moura</LastName>
      <EmailAddress>moura@ece.cmu.edu</EmailAddress>
      <StartDate>02/13/2003</StartDate>
      <EndDate/>
      <RoleCode>Co-Principal Investigator</RoleCode>
    </Investigator>
    <Investigator>
      <FirstName>Markus</FirstName>
      <LastName>Pueschel</LastName>
      <EmailAddress>pueschel@ece.cmu.edu</EmailAddress>
      <StartDate>02/13/2003</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>Carnegie-Mellon University</Name>
      <CityName>PITTSBURGH</CityName>
      <ZipCode>152133815</ZipCode>
      <PhoneNumber>4122689527</PhoneNumber>
      <StreetAddress>5000 Forbes Avenue</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Pennsylvania</StateName>
      <StateCode>PA</StateCode>
    </Institution>
    <FoaInformation>
      <Code>0000099</Code>
      <Name>Other Applications NEC</Name>
    </FoaInformation>
    <FoaInformation>
      <Code>0000912</Code>
      <Name>Computer Science</Name>
    </FoaInformation>
  </Award>
</rootTag>
