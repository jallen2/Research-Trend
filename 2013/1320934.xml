<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>SHF: Small: Generic Dependently Typed Programming by Reflecting a Predicative Hierarchy of Universes</AwardTitle>
    <AwardEffectiveDate>09/01/2013</AwardEffectiveDate>
    <AwardExpirationDate>08/31/2017</AwardExpirationDate>
    <AwardAmount>374960</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05010000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division of Computing and Communication Foundations</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Anindya Banerjee</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>The prevention of bugs in software continues to be a major challenge. One approach is to prove the correctness of software with respect to a specification. This approach is both too challenging and unfamiliar to most programmers because of the varied knowledge needed (knowledge about specifications, programs, and theorem provers). A functional language with a dependent type system supports writing programs, specifications, and proofs that the programs adhere to their specifications in a single language, which reduces the amount of specialized knowledge required and minimizes the number of tools a programmer must learn to be able to effectively write and prove software correct. While the benefits of programming in a dependently typed language are appealing, several issues prevent the immediate adoption of this practice. First, writing dependent types (for example, to encode specifications) involves creating new and highly specific types. Hence, it becomes difficult to reuse existing code when manipulating values of these specialized types. Second, writing proofs in a dependently typed language directly can be painful owing to the lack of proof automation. Because of these issues, existing systems often use a separate language for automating the writing of proofs.&lt;br/&gt;&lt;br/&gt;This project seeks to create a new dependently typed language that addresses both of these problems. The set of types in this language is closed, making it possible to have an eliminator for all types in a predicative hierarchy of universes. Thus, the entire language is reflected as a Martin-Lof universe, supporting generic programming over the entire language. The language addresses the first problem by making it possible to reuse generic functions over newly defined types. It addresses the second problem by interpreting the problem of writing tactics for a proof state as the problem of writing generic functions over a Pi-type. The goal of this proposal is to produce a mechanically verified dependently typed programming language with a principled reflection mechanism that lowers the cost of dependently typed programming.</AbstractNarration>
    <MinAmdLetterDate>08/07/2013</MinAmdLetterDate>
    <MaxAmdLetterDate>08/07/2013</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>1320934</AwardID>
    <Investigator>
      <FirstName>Tim</FirstName>
      <LastName>Sheard</LastName>
      <EmailAddress>sheard@cs.pdx.edu</EmailAddress>
      <StartDate>08/07/2013</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>Portland State University</Name>
      <CityName>Portland</CityName>
      <ZipCode>972070751</ZipCode>
      <PhoneNumber>5037259900</PhoneNumber>
      <StreetAddress>1600 SW 4th Ave</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Oregon</StateName>
      <StateCode>OR</StateCode>
    </Institution>
    <ProgramElement>
      <Code>7943</Code>
      <Text>PROGRAMMING LANGUAGES</Text>
    </ProgramElement>
    <ProgramReference>
      <Code>7923</Code>
      <Text>SMALL PROJECT</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>7943</Code>
      <Text>PROGRAMMING LANGUAGES</Text>
    </ProgramReference>
  </Award>
</rootTag>
