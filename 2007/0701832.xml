<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>Kala: An Efficient and Scalable Time Travel Infrastructure for Concurrent Systems</AwardTitle>
    <AwardEffectiveDate>09/01/2007</AwardEffectiveDate>
    <AwardExpirationDate>08/31/2011</AwardExpirationDate>
    <AwardAmount>325000</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05010000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division of Computing and Communication Foundations</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Sol J. Greenspan</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>0701832&lt;br/&gt;Jagannathan, Suresh&lt;br/&gt;Purdue University&lt;br/&gt;&lt;br/&gt;Kala: An Efficient and Scalable Time Travel Infrastructure for Concurrent Systems Suresh Jagananthan&lt;br/&gt;&lt;br/&gt;The notion of time travel, the ability of an implementation to revert a concurrent computation to an alternative feasible global state is investigated. Recent work on software transactions or speculative execution provide a constrained form of time-travel: when a transaction aborts due to a serializability violation, the transaction's effects are reverted. Similarly, the effects of a speculative thread can be undone if data dependency violations are detected. However, the policies that dictate when a transaction or a speculative action must abort, and where computation resumes, are very rigid, are not specified by the programmer, and often over-constrained.&lt;br/&gt;&lt;br/&gt;The broader ramifications of time travel and revocation on programming language design and specification, compiler analysis, and runtime implementation is the focus of this research. Effective support for time travel can enable a number of new programming abstractions for concurrent programming. This research entails the development of abstractions that revert computation based on programmer-specified invariants, specification techniques that define relations among program states used to guide revocation strategies, static analyses that identify equivalences among states, and compiler and runtime structures to enable efficient reversion of control and state.</AbstractNarration>
    <MinAmdLetterDate>05/24/2007</MinAmdLetterDate>
    <MaxAmdLetterDate>05/24/2007</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>0701832</AwardID>
    <Investigator>
      <FirstName>Suresh</FirstName>
      <LastName>Jagannathan</LastName>
      <EmailAddress>suresh@cs.purdue.edu</EmailAddress>
      <StartDate>05/24/2007</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>Purdue University</Name>
      <CityName>West Lafayette</CityName>
      <ZipCode>479072114</ZipCode>
      <PhoneNumber>7654941055</PhoneNumber>
      <StreetAddress>Young Hall</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Indiana</StateName>
      <StateCode>IN</StateCode>
    </Institution>
    <FoaInformation>
      <Code>0000912</Code>
      <Name>Computer Science</Name>
    </FoaInformation>
  </Award>
</rootTag>
