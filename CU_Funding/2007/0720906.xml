<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>CSR --- SMA: Predictive Testing of System Software</AwardTitle>
    <AwardEffectiveDate>09/01/2007</AwardEffectiveDate>
    <AwardExpirationDate>08/31/2011</AwardExpirationDate>
    <AwardAmount>350000</AwardAmount>
    <AwardInstrument>
      <Value>Continuing grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05050000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division Of Computer and Network Systems</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Mohamed G. Gouda</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>Today's software systems suffer from poor reliability and security,&lt;br/&gt;with software errors costing the U.S. economy upwards of $60 billion&lt;br/&gt;annually. This situation is likely to get worse, as the complexity of&lt;br/&gt;software systems increases without a matching increase in the&lt;br/&gt;effectiveness of software quality tools and techniques. The situation&lt;br/&gt;is particularly challenging for concurrent systems, which pose&lt;br/&gt;significantly higher difficulties for software quality tools, yet are&lt;br/&gt;becoming more widespread with the growing use of multicore machines.&lt;br/&gt;&lt;br/&gt;Static analysis software-quality tools are very precise but do not&lt;br/&gt;scale well to large codes. Testing is easy to use but for good&lt;br/&gt;coverage requires extensive test suites. We propose to bridge the gap&lt;br/&gt;between ad hoc testing and static analysis by combining them in a new&lt;br/&gt;scalable technique called predictive testing. Predictive testing uses&lt;br/&gt;static program analysis to maximize the effectiveness of a given&lt;br/&gt;test-suite for finding in the testing stage bugs that could manifest&lt;br/&gt;in real production runs. Although predictive testing tools use complex&lt;br/&gt;static analysis and automated theorem proving techniques internally,&lt;br/&gt;all of this complexity is hidden from the user by a testing usage&lt;br/&gt;model. For this reason, we expect that such tools can be easily&lt;br/&gt;integrated into existing software engineering processes and will be&lt;br/&gt;usable even by unsophisticated developers.</AbstractNarration>
    <MinAmdLetterDate>07/24/2007</MinAmdLetterDate>
    <MaxAmdLetterDate>07/21/2009</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>0720906</AwardID>
    <Investigator>
      <FirstName>George</FirstName>
      <LastName>Necula</LastName>
      <EmailAddress>necula@cs.berkeley.edu</EmailAddress>
      <StartDate>07/24/2007</StartDate>
      <EndDate/>
      <RoleCode>Co-Principal Investigator</RoleCode>
    </Investigator>
    <Investigator>
      <FirstName>Koushik</FirstName>
      <LastName>Sen</LastName>
      <EmailAddress>ksen@eecs.berkeley.edu</EmailAddress>
      <StartDate>07/24/2007</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>University of California-Berkeley</Name>
      <CityName>BERKELEY</CityName>
      <ZipCode>947045940</ZipCode>
      <PhoneNumber>5106428109</PhoneNumber>
      <StreetAddress>Sponsored Projects Office</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>California</StateName>
      <StateCode>CA</StateCode>
    </Institution>
    <FoaInformation>
      <Code>0000912</Code>
      <Name>Computer Science</Name>
    </FoaInformation>
  </Award>
</rootTag>
