<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>SHF: Medium: Collaborative Research: Principled Optimizing Compilation of Dependently Typed Languages</AwardTitle>
    <AwardEffectiveDate>07/01/2014</AwardEffectiveDate>
    <AwardExpirationDate>10/31/2015</AwardExpirationDate>
    <AwardAmount>600000</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05010000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division of Computing and Communication Foundations</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Anindya Banerjee</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>Title: SHF: Medium: Collaborative Research: Principled Optimizing Compilation of Dependently Typed Languages&lt;br/&gt;&lt;br/&gt;The project focuses on a form of software engineering with program verification: writing programs with logical, machine-checkable proofs of correctness, reliability, or security. Such proofs can be done for programs written in conventional programming languages, but the "proof theory" of these languages is complex and difficult, which makes verification time-consuming and expensive. New, "dependently typed" programming languages use principles of functional programming and advanced type systems to achieve a smoother and cleaner proof theory, so that verifying the correctness and safety of software (written in these new languages) is much easier. In this project, the research is to build compilers for these new languages that are efficient and are verified correct.&lt;br/&gt;&lt;br/&gt;The intellectual merits are in the challenges and opportunities that occur in dependently typed, purely functional contexts, such as the Coq proof assistant. The exciting opportunities that arise only in this context are the ability to choose evaluation order for any sub-term (since Coq's language is pure and total), the ability to open a compiler to user-specified (and certified) rewrite rules that support application-specific optimization, and the ability of programmers to use the Calculus of Inductive Constructions (CiC) proof theory of Coq to verify their programs. The challenges we face, unique to this setting, include the need to determine and erase those terms that are computationally irrelevant. A major foundational challenge is attempting to preserve types (and hence proofs) as we perform lowering transformations, such as conversion to continuation-passing style (CPS) or static single assignment (SSA). Our strategy is to use type and proof-preserving compilation where possible, and where not, to prove a simulation-based notion of correctness. The broader impacts will include (1) pedagogical materials on verified functional programming in Coq; (2) training of graduate students; and (3) improvements in software engineering practice, in enabling practical verified functional programming.</AbstractNarration>
    <MinAmdLetterDate>06/17/2014</MinAmdLetterDate>
    <MaxAmdLetterDate>06/17/2014</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>1407790</AwardID>
    <Investigator>
      <FirstName>J. Gregory</FirstName>
      <LastName>Morrisett</LastName>
      <EmailAddress>greg.morrisett@cornell.edu</EmailAddress>
      <StartDate>06/17/2014</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>Harvard University</Name>
      <CityName>Cambridge</CityName>
      <ZipCode>021385366</ZipCode>
      <PhoneNumber>6174955501</PhoneNumber>
      <StreetAddress>1033 MASSACHUSETTS AVE</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Massachusetts</StateName>
      <StateCode>MA</StateCode>
    </Institution>
    <ProgramElement>
      <Code>7798</Code>
      <Text>SOFTWARE &amp; HARDWARE FOUNDATION</Text>
    </ProgramElement>
    <ProgramElement>
      <Code>6892</Code>
      <Text>CI REUSE</Text>
    </ProgramElement>
    <ProgramReference>
      <Code>7433</Code>
      <Text>CyberInfra Frmwrk 21st (CIF21)</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>7924</Code>
      <Text>MEDIUM PROJECT</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>7943</Code>
      <Text>PROGRAMMING LANGUAGES</Text>
    </ProgramReference>
  </Award>
</rootTag>
